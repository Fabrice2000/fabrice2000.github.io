{"version":3,"file":"static/js/916.ff785b7e.chunk.js","mappings":"+KAIA,MAAMA,EAASC,EAAAA,KAAWC,IAAuF,IAAtF,MAAEC,EAAQ,EAAC,SAAEC,EAAW,CAAC,EAAG,EAAG,GAAE,cAAEC,EAAgB,SAAQ,kBAAEC,GAAmBJ,EACzG,MAAOK,EAAiBC,IAAsBC,EAAAA,EAAAA,WAAS,GACjDC,GAAWC,EAAAA,EAAAA,UAGXC,GAAaC,EAAAA,EAAAA,SAAQ,MACzB,OAAU,sBACV,QAAW,cACX,MAAS,YACT,OAAU,eACR,IAGEC,GAAYD,EAAAA,EAAAA,SAAQ,KACxB,MAAME,EAAYH,EAAWP,IAAkBO,EAAWI,OAC1D,MACgD,iBAAAC,OAC3BF,IACpB,CAACV,EAAeO,KAEb,MAAEM,EAAK,WAAEC,IAAeC,EAAAA,EAAAA,GAAQN,IAChC,QAAEO,IAAYC,EAAAA,EAAAA,GAAcH,EAAYD,GAGxCK,GAA0BC,EAAAA,EAAAA,aAAY,KACtClB,GACFmB,WAAW,IAAMnB,EAAkB,UAAW,MAE/C,CAACA,IAyDJ,OAvDAoB,EAAAA,EAAAA,WAAU,KAERlB,GAAmB,GAGnB,MAAMmB,EAAkBF,WAAW,KAEjCG,OAAOC,OAAOR,GAASS,QAAQC,IACzBA,GACFA,EAAOC,OAAOC,UAKlBC,QAAQC,IAAI,sCAADlB,OAA6BZ,GAAiBuB,OAAOQ,KAAKf,IAErEO,OAAOQ,KAAKf,GAASS,QAAQO,IAC3B,MAAMN,EAASV,EAAQgB,GACnBN,IAEoB,YAAlB1B,GAEF0B,EAAOE,QACJK,QAAQ,KAAM,GACdC,OAAO,IACPC,OACHT,EAAOU,UAAY,EAGnBV,EAAOW,WAAWC,iBAAiB,WAAYpB,IACpB,WAAlBlB,GAET0B,EAAOE,QACJK,QAAQ,KAAM,GACdC,OAAO,IACPC,OACHT,EAAOU,UAAY,MAGnBV,EAAOE,QACJK,QAAQ,KAAM,GACdC,OAAO,IACPC,OACHT,EAAOU,UAAY,MAMzBjC,GAAmB,IAClB,KAEH,MAAO,IAAMoC,aAAajB,IACzB,CAACN,EAAShB,EAAeC,KAG1BuC,EAAAA,EAAAA,KAAA,SAAOC,IAAKpC,EAAUqC,SAAUxC,EAAgByC,UAC9CH,EAAAA,EAAAA,KAAA,aACEI,OAAQ/B,EACRf,MAAOA,EACPC,SAAUA,QAQD,CAAC,sBAAuB,cAAe,cAC/C0B,QAAQoB,IACb,MAAMC,EACsC,iBAAAlC,OACvBiC,GACrB9B,EAAAA,EAAQgC,QAAQD,KAMpB,S","sources":["components/Avatar.jsx"],"sourcesContent":["import React, { useEffect, useState, useRef, useMemo, useCallback } from 'react';\nimport { useGLTF, useAnimations } from '@react-three/drei';\n\n// Mon avatar 3D personnalisÃ© avec animations interactives - OptimisÃ©\nconst Avatar = React.memo(({ scale = 1, position = [0, 0, 0], animationType = 'marche', onAnimationChange }) => {\n  const [isTransitioning, setIsTransitioning] = useState(false);\n  const groupRef = useRef();\n  \n  // MÃ©moisation des modÃ¨les pour Ã©viter les recalculs\n  const modelPaths = useMemo(() => ({\n    'marche': 'marche en ronde.glb',\n    'bonjour': 'bonjour.glb',\n    'rumba': 'rumba.glb',\n    'hiphop': 'hiphop.glb'\n  }), []);\n  \n  // MÃ©moisation du chemin du modÃ¨le\n  const modelPath = useMemo(() => {\n    const modelFile = modelPaths[animationType] || modelPaths.marche;\n    return process.env.NODE_ENV === 'development' \n      ? `${process.env.PUBLIC_URL || ''}/${modelFile}`\n      : `/portfolio-3d/${modelFile}`;\n  }, [animationType, modelPaths]);\n\n  const { scene, animations } = useGLTF(modelPath);\n  const { actions } = useAnimations(animations, scene);\n\n  // Callback optimisÃ© pour la gestion des animations\n  const handleAnimationFinished = useCallback(() => {\n    if (onAnimationChange) {\n      setTimeout(() => onAnimationChange('marche'), 1000);\n    }\n  }, [onAnimationChange]);\n\n  useEffect(() => {\n    // Marquer le dÃ©but de la transition\n    setIsTransitioning(true);\n\n    // Petite pause pour Ã©viter la superposition\n    const transitionDelay = setTimeout(() => {\n      // ArrÃªter toutes les animations prÃ©cÃ©dentes\n      Object.values(actions).forEach(action => {\n        if (action) {\n          action.stop().reset();\n        }\n      });\n\n      // Configuration des animations selon le type\n      console.log(`ðŸŽ­ Chargement animation: ${animationType}`, Object.keys(actions));\n      \n      Object.keys(actions).forEach(actionName => {\n        const action = actions[actionName];\n        if (action) {\n          // Configuration selon le type d'animation\n          if (animationType === 'bonjour') {\n            // Animation de salut - jouer une fois puis revenir Ã  la marche\n            action.reset()\n              .setLoop(2200, 1) // Jouer une fois\n              .fadeIn(0.3)\n              .play();\n            action.timeScale = 1.0;\n            \n            // Retour automatique Ã  la marche aprÃ¨s l'animation de bonjour\n            action.getMixer().addEventListener('finished', handleAnimationFinished);\n          } else if (animationType === 'marche') {\n            // Animation de marche en boucle\n            action.reset()\n              .setLoop(2201, 1) // Boucle infinie\n              .fadeIn(0.3)\n              .play();\n            action.timeScale = 1.2;\n          } else {\n            // Animation rumba, hiphop ou autres - en boucle\n            action.reset()\n              .setLoop(2201, 1)\n              .fadeIn(0.3)\n              .play();\n            action.timeScale = 1.0;\n          }\n        }\n      });\n\n      // Fin de la transition\n      setIsTransitioning(false);\n    }, 200); // DÃ©lai de 200ms pour Ã©viter la superposition\n\n    return () => clearTimeout(transitionDelay);\n  }, [actions, animationType, onAnimationChange]);\n\n  return (\n    <group ref={groupRef} visible={!isTransitioning}>\n      <primitive \n        object={scene} \n        scale={scale} \n        position={position}\n      />\n    </group>\n  );\n});\n\n// PrÃ©chargement des modÃ¨les optimisÃ©\nconst preloadModels = () => {\n  const models = ['marche en ronde.glb', 'bonjour.glb', 'marche.glb'];\n  models.forEach(model => {\n    const path = process.env.NODE_ENV === 'development' \n      ? `${process.env.PUBLIC_URL || ''}/${model}`\n      : `/portfolio-3d/${model}`;\n    useGLTF.preload(path);\n  });\n};\n\npreloadModels();\n\nexport default Avatar;"],"names":["Avatar","React","_ref","scale","position","animationType","onAnimationChange","isTransitioning","setIsTransitioning","useState","groupRef","useRef","modelPaths","useMemo","modelPath","modelFile","marche","concat","scene","animations","useGLTF","actions","useAnimations","handleAnimationFinished","useCallback","setTimeout","useEffect","transitionDelay","Object","values","forEach","action","stop","reset","console","log","keys","actionName","setLoop","fadeIn","play","timeScale","getMixer","addEventListener","clearTimeout","_jsx","ref","visible","children","object","model","path","preload"],"sourceRoot":""}