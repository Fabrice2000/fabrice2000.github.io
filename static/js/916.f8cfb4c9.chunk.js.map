{"version":3,"file":"static/js/916.f8cfb4c9.chunk.js","mappings":"+KAIA,MAAMA,EAASC,EAAAA,KAAWC,IAAuF,IAAtF,MAAEC,EAAQ,EAAC,SAAEC,EAAW,CAAC,EAAG,EAAG,GAAE,cAAEC,EAAgB,SAAQ,kBAAEC,GAAmBJ,EACzG,MAAOK,EAAiBC,IAAsBC,EAAAA,EAAAA,WAAS,GACjDC,GAAWC,EAAAA,EAAAA,UAGXC,GAAaC,EAAAA,EAAAA,SAAQ,MACzB,OAAU,sBACV,QAAW,cACX,MAAS,YACT,OAAU,eACR,IAGEC,GAAYD,EAAAA,EAAAA,SAAQ,KACxB,MAAME,EAAYH,EAAWP,IAAkBO,EAAWI,OAC1D,MACgD,iBAAAC,OAC3BF,IACpB,CAACV,EAAeO,KAEb,MAAEM,EAAK,WAAEC,IAAeC,EAAAA,EAAAA,GAAQN,IAChC,QAAEO,IAAYC,EAAAA,EAAAA,GAAcH,EAAYD,GAGxCK,GAA0BC,EAAAA,EAAAA,aAAY,KACtClB,GACFmB,WAAW,IAAMnB,EAAkB,UAAW,MAE/C,CAACA,IAwDJ,OAtDAoB,EAAAA,EAAAA,WAAU,KAERlB,GAAmB,GAGnB,MAAMmB,EAAkBF,WAAW,KAEjCG,OAAOC,OAAOR,GAASS,QAAQC,IACzBA,GACFA,EAAOC,OAAOC,UAMlBL,OAAOM,KAAKb,GAASS,QAAQK,IAC3B,MAAMJ,EAASV,EAAQc,GACnBJ,IAEoB,YAAlB1B,GAEF0B,EAAOE,QACJG,QAAQ,KAAM,GACdC,OAAO,IACPC,OACHP,EAAOQ,UAAY,EAGnBR,EAAOS,WAAWC,iBAAiB,WAAYlB,IACpB,WAAlBlB,GAET0B,EAAOE,QACJG,QAAQ,KAAM,GACdC,OAAO,IACPC,OACHP,EAAOQ,UAAY,MAGnBR,EAAOE,QACJG,QAAQ,KAAM,GACdC,OAAO,IACPC,OACHP,EAAOQ,UAAY,MAMzB/B,GAAmB,IAClB,KAEH,MAAO,IAAMkC,aAAaf,IACzB,CAACN,EAAShB,EAAeC,KAG1BqC,EAAAA,EAAAA,KAAA,SAAOC,IAAKlC,EAAUmC,SAAUtC,EAAgBuC,UAC9CH,EAAAA,EAAAA,KAAA,aACEI,OAAQ7B,EACRf,MAAOA,EACPC,SAAUA,QAQD,CAAC,sBAAuB,cAAe,cAC/C0B,QAAQkB,IACb,MAAMC,EACsC,iBAAAhC,OACvB+B,GACrB5B,EAAAA,EAAQ8B,QAAQD,KAMpB,S","sources":["components/Avatar.jsx"],"sourcesContent":["import React, { useEffect, useState, useRef, useMemo, useCallback } from 'react';\nimport { useGLTF, useAnimations } from '@react-three/drei';\n\n// Mon avatar 3D personnalisé avec animations interactives - Optimisé\nconst Avatar = React.memo(({ scale = 1, position = [0, 0, 0], animationType = 'marche', onAnimationChange }) => {\n  const [isTransitioning, setIsTransitioning] = useState(false);\n  const groupRef = useRef();\n  \n  // Mémoisation des modèles pour éviter les recalculs\n  const modelPaths = useMemo(() => ({\n    'marche': 'marche en ronde.glb',\n    'bonjour': 'bonjour.glb',\n    'rumba': 'rumba.glb',\n    'hiphop': 'hiphop.glb'\n  }), []);\n  \n  // Mémoisation du chemin du modèle\n  const modelPath = useMemo(() => {\n    const modelFile = modelPaths[animationType] || modelPaths.marche;\n    return process.env.NODE_ENV === 'development' \n      ? `${process.env.PUBLIC_URL || ''}/${modelFile}`\n      : `/portfolio-3d/${modelFile}`;\n  }, [animationType, modelPaths]);\n\n  const { scene, animations } = useGLTF(modelPath);\n  const { actions } = useAnimations(animations, scene);\n\n  // Callback optimisé pour la gestion des animations\n  const handleAnimationFinished = useCallback(() => {\n    if (onAnimationChange) {\n      setTimeout(() => onAnimationChange('marche'), 1000);\n    }\n  }, [onAnimationChange]);\n\n  useEffect(() => {\n    // Marquer le début de la transition\n    setIsTransitioning(true);\n\n    // Petite pause pour éviter la superposition\n    const transitionDelay = setTimeout(() => {\n      // Arrêter toutes les animations précédentes\n      Object.values(actions).forEach(action => {\n        if (action) {\n          action.stop().reset();\n        }\n      });\n\n      // Configuration des animations selon le type\n      \n      Object.keys(actions).forEach(actionName => {\n        const action = actions[actionName];\n        if (action) {\n          // Configuration selon le type d'animation\n          if (animationType === 'bonjour') {\n            // Animation de salut - jouer une fois puis revenir à la marche\n            action.reset()\n              .setLoop(2200, 1) // Jouer une fois\n              .fadeIn(0.3)\n              .play();\n            action.timeScale = 1.0;\n            \n            // Retour automatique à la marche après l'animation de bonjour\n            action.getMixer().addEventListener('finished', handleAnimationFinished);\n          } else if (animationType === 'marche') {\n            // Animation de marche en boucle\n            action.reset()\n              .setLoop(2201, 1) // Boucle infinie\n              .fadeIn(0.3)\n              .play();\n            action.timeScale = 1.2;\n          } else {\n            // Animation rumba, hiphop ou autres - en boucle\n            action.reset()\n              .setLoop(2201, 1)\n              .fadeIn(0.3)\n              .play();\n            action.timeScale = 1.0;\n          }\n        }\n      });\n\n      // Fin de la transition\n      setIsTransitioning(false);\n    }, 200); // Délai de 200ms pour éviter la superposition\n\n    return () => clearTimeout(transitionDelay);\n  }, [actions, animationType, onAnimationChange]);\n\n  return (\n    <group ref={groupRef} visible={!isTransitioning}>\n      <primitive \n        object={scene} \n        scale={scale} \n        position={position}\n      />\n    </group>\n  );\n});\n\n// Préchargement des modèles optimisé\nconst preloadModels = () => {\n  const models = ['marche en ronde.glb', 'bonjour.glb', 'marche.glb'];\n  models.forEach(model => {\n    const path = process.env.NODE_ENV === 'development' \n      ? `${process.env.PUBLIC_URL || ''}/${model}`\n      : `/portfolio-3d/${model}`;\n    useGLTF.preload(path);\n  });\n};\n\npreloadModels();\n\nexport default Avatar;"],"names":["Avatar","React","_ref","scale","position","animationType","onAnimationChange","isTransitioning","setIsTransitioning","useState","groupRef","useRef","modelPaths","useMemo","modelPath","modelFile","marche","concat","scene","animations","useGLTF","actions","useAnimations","handleAnimationFinished","useCallback","setTimeout","useEffect","transitionDelay","Object","values","forEach","action","stop","reset","keys","actionName","setLoop","fadeIn","play","timeScale","getMixer","addEventListener","clearTimeout","_jsx","ref","visible","children","object","model","path","preload"],"sourceRoot":""}